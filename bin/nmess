#!/usr/bin/env node

var cli = require('commander'),
	uuid = require('uuid'),
	down = require('download'),
	replace = require('replace'),
	fs = require('fs-extra'),
	path = require('path'),
	pkg = require('../package'),
	exec = require('child_process').exec,
	github = require('octonode');

cli
	.version(pkg.version)
	.usage('[options] <name>')
	.option('-d, --directory [directory]', 'Application directory [name]')
	.option('-s, --secret [secret]', 'Session secret [uuid.v4()]')
	.option('-b, --database [db]', 'Local database path [\'localhost/\' + name]')
	.option('-p, --port [port]', 'Server listening port [3000]')
	.parse(process.argv);

var cacheroot = path.resolve(path.join(process.env.HOME || process.env.HOMEPATH || process.env.USERPROFILE, '.nmess')),
	cachedir = path.join(cacheroot, 'cache'),
	cachecommit = path.join(cacheroot, 'lastcommit');

var rawname = cli.args[0].replace(/\/$/, ''),
	options = {
		name: path.basename(rawname) || (function() {
			throw new Error('Name not specified.')
		})()
	};

options.directory = path.join(path.dirname(rawname), cli.directory || options.name);
options.secret = cli.secret || uuid.v4();
options.database = cli.database || 'localhost/' + options.name;
options.port = cli.port || 3000;

var die = function(err) {
	console.log('Error: ' + JSON.stringify(err, null, 4));
};

var download = function() {
	console.log('Downloading...');
	(new down()).get('https://github.com/edge/nmess/archive/master.zip', cachedir, {
		extract: true,
		strip: 1
	}).run(function(err) {
		if (err) {
			die(arguments);
		}
		else {
			install(true);
		}
	});
};

var install = function(online) {

	if (online) {
		console.log('Installing...');

		exec('cd ' + cachedir + ' && npm install', function(err) {
			if (err) {
				die(arguments);
			}
			else {
				populate();
			}
		});
	}
	else {
		populate();
	}

};

var populate = function() {

	console.log('Populating...');

	fs.mkdirp(options.directory, function(err) {

		if (err) {
			die(arguments);
		}
		else {
			fs.copy(cachedir, options.directory, function(err) {
				if (err) {
					die(arguments);
				}
				else {
					var renameRecursive = function(dir, find, replacewith) {
							var children = fs.readdirSync(dir),
								current,
								replacecurrent;
							for (var i = 0; i < children.length; i++) {
								current = path.join(dir, children[i]);
								if (children[i] != 'node_modules') {
									replacecurrent = current.replace(find, replacewith);
									fs.renameSync(current, replacecurrent);
									if (fs.statSync(replacecurrent).isDirectory()) {
										renameRecursive(replacecurrent, find, replacewith);
									}
								}
							}
						},
						populateTemplates = function(find, replacewith) {
							renameRecursive(options.directory, find, replacewith);
							replace({
								regex: find,
								replacement: replacewith,
								paths: [options.directory],
								exclude: 'node_modules',
								recursive: true,
								silent: true
							});
						};

					populateTemplates(/__name__/g, options.name);
					populateTemplates(/__secret__/g, options.secret);
					populateTemplates(/__db__/g, options.database);
					populateTemplates(/"port": 3000/g, '"port": ' + options.port);

					build();
				}
			});
		}

	});

};

var build = function() {

	console.log('Building...');

	exec('cd ' + options.directory + ' && gulp compile', function(err) {
		if (err) {
			die(arguments);
		}
		else {
			console.log('Node MESS Application generated with:')
			console.log('name:      ' + options.name);
			console.log('directory: ' + options.directory);
			console.log('secret:    ' + options.secret);
			console.log('db:        ' + options.database);
			console.log('port:      ' + options.port);
		}
	});
};

fs.ensureFileSync(cachecommit);
fs.ensureDirSync(cachedir);

var lastcommit = fs.readFileSync(cachecommit),
	newcommit;

github.client().repo('edge/nmess').commits(function(err, commits) {
	if (err && err.code !== 'ENOTFOUND') {
		die(arguments);
	}
	else if (err && err.code === 'ENOTFOUND') {
		console.log('No internet connection, using cached skeleton.');
		install(false);
	}
	else {
		newcommit = commits[0].sha;
		if (newcommit == lastcommit) {
			console.log('Up-to-date skeleton found in cache.');
			install(true);
		}
		else {
			download();
			fs.writeFileSync(cachecommit, newcommit);
			console.log('Cache updated with new skeleton.');
		}
	}
});
